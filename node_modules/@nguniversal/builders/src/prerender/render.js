/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/builders/src/prerender/render", ["require", "exports", "@nguniversal/common/engine", "fs", "path"], factory);
    }
})(function (require, exports) {
    "use strict";
    var __syncRequire = typeof module === "object" && typeof module.exports === "object";
    Object.defineProperty(exports, "__esModule", { value: true });
    const engine_1 = require("@nguniversal/common/engine");
    const fs = require("fs");
    const path = require("path");
    const [indexHtml, indexFile, serverBundlePath, browserOutputPath, deployUrl, inlineCritialCss, minifyCss, ...routes] = process.argv.slice(2);
    /**
     * Handles importing the server bundle.
     */
    function getServerBundle(bundlePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const { AppServerModule, AppServerModuleNgFactory, renderModule, renderModuleFactory, } = yield __syncRequire ? Promise.resolve().then(() => require(bundlePath)) : new Promise((resolve_1, reject_1) => { require([bundlePath], resolve_1, reject_1); });
            if (renderModuleFactory && AppServerModuleNgFactory) {
                // Happens when in ViewEngine mode.
                return {
                    renderModuleFn: renderModuleFactory,
                    AppServerModuleDef: AppServerModuleNgFactory,
                };
            }
            if (renderModule && AppServerModule) {
                // Happens when in Ivy mode.
                return {
                    renderModuleFn: renderModule,
                    AppServerModuleDef: AppServerModule,
                };
            }
            throw new Error(`renderModule method and/or AppServerModule were not exported from: ${serverBundlePath}.`);
        });
    }
    /**
     * Renders each route in routes and writes them to <outputPath>/<route>/index.html.
     */
    // tslint:disable-next-line: no-floating-promises
    (() => __awaiter(void 0, void 0, void 0, function* () {
        if (!process.send) {
            throw new Error('Process must be spawned with an IPC channel.');
        }
        const browserIndexOutputPath = path.join(browserOutputPath, indexFile);
        let inlineCriticalCssProcessor;
        if (inlineCritialCss === 'true') {
            inlineCriticalCssProcessor = new engine_1.ÉµInlineCriticalCssProcessor({
                deployUrl,
                minify: minifyCss === 'true',
            });
        }
        for (const route of routes) {
            const outputFolderPath = path.join(browserOutputPath, route);
            const outputIndexPath = path.join(outputFolderPath, 'index.html');
            try {
                const { renderModuleFn, AppServerModuleDef } = yield getServerBundle(serverBundlePath);
                let html = yield renderModuleFn(AppServerModuleDef, {
                    document: indexHtml,
                    url: route,
                });
                if (inlineCriticalCssProcessor) {
                    const { content, warnings, errors } = yield inlineCriticalCssProcessor.process(html, {
                        outputPath: browserOutputPath,
                    });
                    // tslint:disable-next-line: no-non-null-assertion
                    warnings === null || warnings === void 0 ? void 0 : warnings.forEach((message) => process.send({ logLevel: 'warn', message }));
                    // tslint:disable-next-line: no-non-null-assertion
                    errors === null || errors === void 0 ? void 0 : errors.forEach((message) => process.send({ logLevel: 'error', message }));
                    html = content;
                }
                // This case happens when we are prerendering "/".
                if (browserIndexOutputPath === outputIndexPath) {
                    const browserIndexOutputPathOriginal = path.join(browserOutputPath, 'index.original.html');
                    fs.renameSync(browserIndexOutputPath, browserIndexOutputPathOriginal);
                }
                fs.mkdirSync(outputFolderPath, { recursive: true });
                fs.writeFileSync(outputIndexPath, html);
                process.send({ success: true, outputIndexPath });
            }
            catch (e) {
                process.send({ success: false, error: e.message, outputIndexPath });
                return;
            }
        }
    }))();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbW9kdWxlcy9idWlsZGVycy9zcmMvcHJlcmVuZGVyL3JlbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFSCx1REFBdUc7SUFDdkcseUJBQXlCO0lBQ3pCLDZCQUE2QjtJQUU3QixNQUFNLENBQ0osU0FBUyxFQUNULFNBQVMsRUFDVCxnQkFBZ0IsRUFDaEIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxnQkFBZ0IsRUFDaEIsU0FBUyxFQUNULEdBQUcsTUFBTSxDQUNWLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFMUI7O09BRUc7SUFDSCxTQUFlLGVBQWUsQ0FBQyxVQUFrQjs7WUFDL0MsTUFBTSxFQUNKLGVBQWUsRUFDZix3QkFBd0IsRUFDeEIsWUFBWSxFQUNaLG1CQUFtQixHQUNwQixHQUFHLDJEQUFhLFVBQVUscURBQVYsVUFBVSwyQkFBQyxDQUFDO1lBRTdCLElBQUksbUJBQW1CLElBQUksd0JBQXdCLEVBQUU7Z0JBQ25ELG1DQUFtQztnQkFDbkMsT0FBTztvQkFDTCxjQUFjLEVBQUUsbUJBQW1CO29CQUNuQyxrQkFBa0IsRUFBRSx3QkFBd0I7aUJBQzdDLENBQUM7YUFDSDtZQUVELElBQUksWUFBWSxJQUFJLGVBQWUsRUFBRTtnQkFDbkMsNEJBQTRCO2dCQUM1QixPQUFPO29CQUNMLGNBQWMsRUFBRSxZQUFZO29CQUM1QixrQkFBa0IsRUFBRSxlQUFlO2lCQUNwQyxDQUFDO2FBQ0g7WUFFRCxNQUFNLElBQUksS0FBSyxDQUNiLHNFQUFzRSxnQkFBZ0IsR0FBRyxDQUMxRixDQUFDO1FBQ0osQ0FBQztLQUFBO0lBRUQ7O09BRUc7SUFDSCxpREFBaUQ7SUFDakQsQ0FBQyxHQUFTLEVBQUU7UUFDVixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLDhDQUE4QyxDQUFDLENBQUM7U0FDakU7UUFFRCxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDdkUsSUFBSSwwQkFBa0UsQ0FBQztRQUV2RSxJQUFJLGdCQUFnQixLQUFLLE1BQU0sRUFBRTtZQUMvQiwwQkFBMEIsR0FBRyxJQUFJLG9DQUEwQixDQUFDO2dCQUMxRCxTQUFTO2dCQUNULE1BQU0sRUFBRSxTQUFTLEtBQUssTUFBTTthQUM3QixDQUFDLENBQUM7U0FDSjtRQUVELEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO1lBQzFCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUM3RCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLFlBQVksQ0FBQyxDQUFDO1lBRWxFLElBQUk7Z0JBQ0YsTUFBTSxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxHQUFHLE1BQU0sZUFBZSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Z0JBRXZGLElBQUksSUFBSSxHQUFHLE1BQU0sY0FBYyxDQUFDLGtCQUFrQixFQUFFO29CQUNsRCxRQUFRLEVBQUUsU0FBUztvQkFDbkIsR0FBRyxFQUFFLEtBQUs7aUJBQ1gsQ0FBQyxDQUFDO2dCQUVILElBQUksMEJBQTBCLEVBQUU7b0JBQzlCLE1BQU0sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxHQUFHLE1BQU0sMEJBQTBCLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTt3QkFDbkYsVUFBVSxFQUFFLGlCQUFpQjtxQkFDOUIsQ0FBQyxDQUFDO29CQUVILGtEQUFrRDtvQkFDbEQsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUssQ0FBQyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUM3RSxrREFBa0Q7b0JBQ2xELE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFLLENBQUMsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDNUUsSUFBSSxHQUFHLE9BQU8sQ0FBQztpQkFDaEI7Z0JBRUQsa0RBQWtEO2dCQUNsRCxJQUFJLHNCQUFzQixLQUFLLGVBQWUsRUFBRTtvQkFDOUMsTUFBTSw4QkFBOEIsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLHFCQUFxQixDQUFDLENBQUM7b0JBQzNGLEVBQUUsQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsOEJBQThCLENBQUMsQ0FBQztpQkFDdkU7Z0JBRUQsRUFBRSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO2dCQUNwRCxFQUFFLENBQUMsYUFBYSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFFeEMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQzthQUNsRDtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7Z0JBRXBFLE9BQU87YUFDUjtTQUNGO0lBQ0gsQ0FBQyxDQUFBLENBQUMsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7IMm1SW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3IgYXMgSW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3IgfSBmcm9tICdAbmd1bml2ZXJzYWwvY29tbW9uL2VuZ2luZSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5jb25zdCBbXG4gIGluZGV4SHRtbCxcbiAgaW5kZXhGaWxlLFxuICBzZXJ2ZXJCdW5kbGVQYXRoLFxuICBicm93c2VyT3V0cHV0UGF0aCxcbiAgZGVwbG95VXJsLFxuICBpbmxpbmVDcml0aWFsQ3NzLFxuICBtaW5pZnlDc3MsXG4gIC4uLnJvdXRlc1xuXSA9IHByb2Nlc3MuYXJndi5zbGljZSgyKTtcblxuLyoqXG4gKiBIYW5kbGVzIGltcG9ydGluZyB0aGUgc2VydmVyIGJ1bmRsZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmVyQnVuZGxlKGJ1bmRsZVBhdGg6IHN0cmluZykge1xuICBjb25zdCB7XG4gICAgQXBwU2VydmVyTW9kdWxlLFxuICAgIEFwcFNlcnZlck1vZHVsZU5nRmFjdG9yeSxcbiAgICByZW5kZXJNb2R1bGUsXG4gICAgcmVuZGVyTW9kdWxlRmFjdG9yeSxcbiAgfSA9IGF3YWl0IGltcG9ydChidW5kbGVQYXRoKTtcblxuICBpZiAocmVuZGVyTW9kdWxlRmFjdG9yeSAmJiBBcHBTZXJ2ZXJNb2R1bGVOZ0ZhY3RvcnkpIHtcbiAgICAvLyBIYXBwZW5zIHdoZW4gaW4gVmlld0VuZ2luZSBtb2RlLlxuICAgIHJldHVybiB7XG4gICAgICByZW5kZXJNb2R1bGVGbjogcmVuZGVyTW9kdWxlRmFjdG9yeSxcbiAgICAgIEFwcFNlcnZlck1vZHVsZURlZjogQXBwU2VydmVyTW9kdWxlTmdGYWN0b3J5LFxuICAgIH07XG4gIH1cblxuICBpZiAocmVuZGVyTW9kdWxlICYmIEFwcFNlcnZlck1vZHVsZSkge1xuICAgIC8vIEhhcHBlbnMgd2hlbiBpbiBJdnkgbW9kZS5cbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyTW9kdWxlRm46IHJlbmRlck1vZHVsZSxcbiAgICAgIEFwcFNlcnZlck1vZHVsZURlZjogQXBwU2VydmVyTW9kdWxlLFxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYHJlbmRlck1vZHVsZSBtZXRob2QgYW5kL29yIEFwcFNlcnZlck1vZHVsZSB3ZXJlIG5vdCBleHBvcnRlZCBmcm9tOiAke3NlcnZlckJ1bmRsZVBhdGh9LmAsXG4gICk7XG59XG5cbi8qKlxuICogUmVuZGVycyBlYWNoIHJvdXRlIGluIHJvdXRlcyBhbmQgd3JpdGVzIHRoZW0gdG8gPG91dHB1dFBhdGg+Lzxyb3V0ZT4vaW5kZXguaHRtbC5cbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1mbG9hdGluZy1wcm9taXNlc1xuKGFzeW5jICgpID0+IHtcbiAgaWYgKCFwcm9jZXNzLnNlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2Nlc3MgbXVzdCBiZSBzcGF3bmVkIHdpdGggYW4gSVBDIGNoYW5uZWwuJyk7XG4gIH1cblxuICBjb25zdCBicm93c2VySW5kZXhPdXRwdXRQYXRoID0gcGF0aC5qb2luKGJyb3dzZXJPdXRwdXRQYXRoLCBpbmRleEZpbGUpO1xuICBsZXQgaW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3I6IElubGluZUNyaXRpY2FsQ3NzUHJvY2Vzc29yIHwgdW5kZWZpbmVkO1xuXG4gIGlmIChpbmxpbmVDcml0aWFsQ3NzID09PSAndHJ1ZScpIHtcbiAgICBpbmxpbmVDcml0aWNhbENzc1Byb2Nlc3NvciA9IG5ldyBJbmxpbmVDcml0aWNhbENzc1Byb2Nlc3Nvcih7XG4gICAgICBkZXBsb3lVcmwsXG4gICAgICBtaW5pZnk6IG1pbmlmeUNzcyA9PT0gJ3RydWUnLFxuICAgIH0pO1xuICB9XG5cbiAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpIHtcbiAgICBjb25zdCBvdXRwdXRGb2xkZXJQYXRoID0gcGF0aC5qb2luKGJyb3dzZXJPdXRwdXRQYXRoLCByb3V0ZSk7XG4gICAgY29uc3Qgb3V0cHV0SW5kZXhQYXRoID0gcGF0aC5qb2luKG91dHB1dEZvbGRlclBhdGgsICdpbmRleC5odG1sJyk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyByZW5kZXJNb2R1bGVGbiwgQXBwU2VydmVyTW9kdWxlRGVmIH0gPSBhd2FpdCBnZXRTZXJ2ZXJCdW5kbGUoc2VydmVyQnVuZGxlUGF0aCk7XG5cbiAgICAgIGxldCBodG1sID0gYXdhaXQgcmVuZGVyTW9kdWxlRm4oQXBwU2VydmVyTW9kdWxlRGVmLCB7XG4gICAgICAgIGRvY3VtZW50OiBpbmRleEh0bWwsXG4gICAgICAgIHVybDogcm91dGUsXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlubGluZUNyaXRpY2FsQ3NzUHJvY2Vzc29yKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudCwgd2FybmluZ3MsIGVycm9ycyB9ID0gYXdhaXQgaW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3IucHJvY2VzcyhodG1sLCB7XG4gICAgICAgICAgb3V0cHV0UGF0aDogYnJvd3Nlck91dHB1dFBhdGgsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHdhcm5pbmdzPy5mb3JFYWNoKChtZXNzYWdlKSA9PiBwcm9jZXNzLnNlbmQhKHsgbG9nTGV2ZWw6ICd3YXJuJywgbWVzc2FnZSB9KSk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGVycm9ycz8uZm9yRWFjaCgobWVzc2FnZSkgPT4gcHJvY2Vzcy5zZW5kISh7IGxvZ0xldmVsOiAnZXJyb3InLCBtZXNzYWdlIH0pKTtcbiAgICAgICAgaHRtbCA9IGNvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gd2UgYXJlIHByZXJlbmRlcmluZyBcIi9cIi5cbiAgICAgIGlmIChicm93c2VySW5kZXhPdXRwdXRQYXRoID09PSBvdXRwdXRJbmRleFBhdGgpIHtcbiAgICAgICAgY29uc3QgYnJvd3NlckluZGV4T3V0cHV0UGF0aE9yaWdpbmFsID0gcGF0aC5qb2luKGJyb3dzZXJPdXRwdXRQYXRoLCAnaW5kZXgub3JpZ2luYWwuaHRtbCcpO1xuICAgICAgICBmcy5yZW5hbWVTeW5jKGJyb3dzZXJJbmRleE91dHB1dFBhdGgsIGJyb3dzZXJJbmRleE91dHB1dFBhdGhPcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIGZzLm1rZGlyU3luYyhvdXRwdXRGb2xkZXJQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMob3V0cHV0SW5kZXhQYXRoLCBodG1sKTtcblxuICAgICAgcHJvY2Vzcy5zZW5kKHsgc3VjY2VzczogdHJ1ZSwgb3V0cHV0SW5kZXhQYXRoIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHByb2Nlc3Muc2VuZCh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZS5tZXNzYWdlLCBvdXRwdXRJbmRleFBhdGggfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn0pKCk7XG4iXX0=