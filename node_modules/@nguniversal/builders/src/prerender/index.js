/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/builders/src/prerender/index", ["require", "exports", "@angular-devkit/architect", "@angular-devkit/build-angular/src/utils/normalize-optimization", "@angular-devkit/build-angular/src/utils/service-worker", "@angular-devkit/core", "@angular-devkit/core/node", "child_process", "fs", "ora", "path", "util", "@nguniversal/builders/src/prerender/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.execute = exports.readFile = void 0;
    const architect_1 = require("@angular-devkit/architect");
    const normalize_optimization_1 = require("@angular-devkit/build-angular/src/utils/normalize-optimization");
    const service_worker_1 = require("@angular-devkit/build-angular/src/utils/service-worker");
    const core_1 = require("@angular-devkit/core");
    const node_1 = require("@angular-devkit/core/node");
    const child_process_1 = require("child_process");
    const fs = require("fs");
    const ora = require("ora");
    const path = require("path");
    const util_1 = require("util");
    const utils_1 = require("@nguniversal/builders/src/prerender/utils");
    exports.readFile = util_1.promisify(fs.readFile);
    /**
     * Schedules the server and browser builds and returns their results if both builds are successful.
     */
    function _scheduleBuilds(options, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
            const serverTarget = architect_1.targetFromTargetString(options.serverTarget);
            const browserTargetRun = yield context.scheduleTarget(browserTarget, {
                watch: false,
                serviceWorker: false,
                // todo: handle service worker augmentation
            });
            const serverTargetRun = yield context.scheduleTarget(serverTarget, {
                watch: false,
            });
            try {
                const [browserResult, serverResult] = yield Promise.all([
                    browserTargetRun.result,
                    serverTargetRun.result,
                ]);
                const success = browserResult.success && serverResult.success && browserResult.baseOutputPath !== undefined;
                const error = browserResult.error || serverResult.error;
                return { success, error, browserResult, serverResult };
            }
            catch (e) {
                return { success: false, error: e.message };
            }
            finally {
                yield Promise.all([browserTargetRun.stop(), serverTargetRun.stop()]);
            }
        });
    }
    /**
     * Renders each route and writes them to
     * <route>/index.html for each output path in the browser result.
     */
    function _renderUniversal(routes, context, browserResult, serverResult, browserOptions, numProcesses) {
        return __awaiter(this, void 0, void 0, function* () {
            const host = new node_1.NodeJsSyncHost();
            const projectName = context.target && context.target.project;
            if (!projectName) {
                throw new Error('The builder requires a target.');
            }
            const root = core_1.normalize(context.workspaceRoot);
            const projectMetadata = yield context.getProjectMetadata(projectName);
            const projectRoot = core_1.resolve(root, core_1.normalize(projectMetadata.root || ''));
            // Users can specify a different base html file e.g. "src/home.html"
            const indexFile = utils_1.getIndexOutputFile(browserOptions);
            const { styles: normalizedStylesOptimization } = normalize_optimization_1.normalizeOptimization(browserOptions.optimization);
            // We need to render the routes for each locale from the browser output.
            for (const outputPath of browserResult.outputPaths) {
                const browserIndexInputPath = path.join(outputPath, indexFile);
                let indexHtml = yield exports.readFile(browserIndexInputPath, 'utf8');
                if (normalizedStylesOptimization.inlineCritical) {
                    // Workaround for https://github.com/GoogleChromeLabs/critters/issues/64
                    indexHtml = indexHtml.replace(/ media=\"print\" onload=\"this\.media='all'"><noscript><link .+?><\/noscript>/g, '>');
                }
                const { baseOutputPath = '' } = serverResult;
                const localeDirectory = path.relative(browserResult.baseOutputPath, outputPath);
                const serverBundlePath = path.join(baseOutputPath, localeDirectory, 'main.js');
                if (!fs.existsSync(serverBundlePath)) {
                    throw new Error(`Could not find the main bundle: ${serverBundlePath}`);
                }
                const spinner = ora(`Prerendering ${routes.length} route(s) to ${outputPath}...`).start();
                try {
                    const workerFile = path.join(__dirname, 'render.js');
                    const childProcesses = utils_1.shardArray(routes, numProcesses).map((routesShard) => new Promise((resolve, reject) => {
                        child_process_1.fork(workerFile, [
                            indexHtml.replace('</html>', '<!-- This page was prerendered with Angular Universal -->\n</html>'),
                            indexFile,
                            serverBundlePath,
                            outputPath,
                            browserOptions.deployUrl || '',
                            normalizedStylesOptimization.inlineCritical ? 'true' : 'false',
                            normalizedStylesOptimization.minify ? 'true' : 'false',
                            ...routesShard,
                        ])
                            .on('message', (data) => {
                            if (data.success === false) {
                                reject(new Error(`Unable to render ${data.outputIndexPath}.\nError: ${data.error}`));
                                return;
                            }
                            if (data.logLevel) {
                                spinner.stop();
                                context.logger.log(data.logLevel, data.message);
                                spinner.start();
                            }
                        })
                            .on('exit', resolve)
                            .on('error', reject);
                    }));
                    yield Promise.all(childProcesses);
                }
                catch (error) {
                    spinner.fail(`Prerendering routes to ${outputPath} failed.`);
                    return { success: false, error: error.message };
                }
                spinner.succeed(`Prerendering routes to ${outputPath} complete.`);
                if (browserOptions.serviceWorker) {
                    spinner.start('Generating service worker...');
                    try {
                        yield service_worker_1.augmentAppWithServiceWorker(root, projectRoot, core_1.normalize(outputPath), browserOptions.baseHref || '/', browserOptions.ngswConfigPath);
                    }
                    catch (error) {
                        spinner.fail('Service worker generation failed.');
                        return { success: false, error: error.message };
                    }
                    spinner.succeed('Service worker generation complete.');
                }
            }
            return browserResult;
        });
    }
    /**
     * Builds the browser and server, then renders each route in options.routes
     * and writes them to prerender/<route>/index.html for each output path in
     * the browser result.
     */
    function execute(options, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
            const browserOptions = (yield context.getTargetOptions(browserTarget));
            const tsConfigPath = typeof browserOptions.tsConfig === 'string' ? browserOptions.tsConfig : undefined;
            const routes = yield utils_1.getRoutes(options, tsConfigPath, context);
            if (!routes.length) {
                throw new Error(`Could not find any routes to prerender.`);
            }
            const result = yield _scheduleBuilds(options, context);
            const { success, error, browserResult, serverResult } = result;
            if (!success || !browserResult || !serverResult) {
                return { success, error };
            }
            return _renderUniversal(routes, context, browserResult, serverResult, browserOptions, options.numProcesses);
        });
    }
    exports.execute = execute;
    exports.default = architect_1.createBuilder(execute);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9wcmVyZW5kZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgseURBS21DO0lBRW5DLDJHQUF1RztJQUN2RywyRkFBcUc7SUFDckcsK0NBQXlFO0lBQ3pFLG9EQUEyRDtJQUMzRCxpREFBcUM7SUFDckMseUJBQXlCO0lBQ3pCLDJCQUEyQjtJQUMzQiw2QkFBNkI7SUFDN0IsK0JBQWlDO0lBRWpDLHFFQUFvRTtJQUV2RCxRQUFBLFFBQVEsR0FBRyxnQkFBUyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQWEvQzs7T0FFRztJQUNILFNBQWUsZUFBZSxDQUM1QixPQUFnQyxFQUNoQyxPQUF1Qjs7WUFFdkIsTUFBTSxhQUFhLEdBQUcsa0NBQXNCLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3BFLE1BQU0sWUFBWSxHQUFHLGtDQUFzQixDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUVsRSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUU7Z0JBQ25FLEtBQUssRUFBRSxLQUFLO2dCQUNaLGFBQWEsRUFBRSxLQUFLO2dCQUNwQiwyQ0FBMkM7YUFDNUMsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxlQUFlLEdBQUcsTUFBTSxPQUFPLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRTtnQkFDakUsS0FBSyxFQUFFLEtBQUs7YUFDYixDQUFDLENBQUM7WUFFSCxJQUFJO2dCQUNGLE1BQU0sQ0FBQyxhQUFhLEVBQUUsWUFBWSxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDO29CQUNyRCxnQkFBZ0IsQ0FBQyxNQUF3QztvQkFDekQsZUFBZSxDQUFDLE1BQXdDO2lCQUMx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M0IsT0FBZ0MsRUFDaEMsT0FBdUI7O1lBRXZCLE1BQU0sYUFBYSxHQUFHLGtDQUFzQixDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNwRSxNQUFNLGNBQWMsR0FBSSxDQUFDLE1BQU0sT0FBTyxDQUFDLGdCQUFnQixDQUNyRCxhQUFhLENBQ2QsQ0FBc0MsQ0FBQztZQUN4QyxNQUFNLFlBQVksR0FDaEIsT0FBTyxjQUFjLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBRXBGLE1BQU0sTUFBTSxHQUFHLE1BQU0saUJBQVMsQ0FBQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQy9ELElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO2dCQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7YUFDNUQ7WUFFRCxNQUFNLE1BQU0sR0FBRyxNQUFNLGVBQWUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDdkQsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxHQUFHLE1BQU0sQ0FBQztZQUMvRCxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUMvQyxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBbUIsQ0FBQzthQUM1QztZQUVELE9BQU8sZ0JBQWdCLENBQ3JCLE1BQU0sRUFDTixPQUFPLEVBQ1AsYUFBYSxFQUNiLFlBQVksRUFDWixjQUFjLEVBQ2QsT0FBTyxDQUFDLFlBQVksQ0FDckIsQ0FBQztRQUNKLENBQUM7S0FBQTtJQTlCRCwwQkE4QkM7SUFFRCxrQkFBZSx5QkFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7XG4gIEJ1aWxkZXJDb250ZXh0LFxuICBCdWlsZGVyT3V0cHV0LFxuICBjcmVhdGVCdWlsZGVyLFxuICB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nLFxufSBmcm9tICdAYW5ndWxhci1kZXZraXQvYXJjaGl0ZWN0JztcbmltcG9ydCB7IEJyb3dzZXJCdWlsZGVyT3B0aW9ucyB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9idWlsZC1hbmd1bGFyJztcbmltcG9ydCB7IG5vcm1hbGl6ZU9wdGltaXphdGlvbiB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9idWlsZC1hbmd1bGFyL3NyYy91dGlscy9ub3JtYWxpemUtb3B0aW1pemF0aW9uJztcbmltcG9ydCB7IGF1Z21lbnRBcHBXaXRoU2VydmljZVdvcmtlciB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9idWlsZC1hbmd1bGFyL3NyYy91dGlscy9zZXJ2aWNlLXdvcmtlcic7XG5pbXBvcnQgeyBub3JtYWxpemUsIHJlc29sdmUgYXMgcmVzb2x2ZVBhdGggfSBmcm9tICdAYW5ndWxhci1kZXZraXQvY29yZSc7XG5pbXBvcnQgeyBOb2RlSnNTeW5jSG9zdCB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlL25vZGUnO1xuaW1wb3J0IHsgZm9yayB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgb3JhIGZyb20gJ29yYSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBQcmVyZW5kZXJCdWlsZGVyT3B0aW9ucywgUHJlcmVuZGVyQnVpbGRlck91dHB1dCB9IGZyb20gJy4vbW9kZWxzJztcbmltcG9ydCB7IGdldEluZGV4T3V0cHV0RmlsZSwgZ2V0Um91dGVzLCBzaGFyZEFycmF5IH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjb25zdCByZWFkRmlsZSA9IHByb21pc2lmeShmcy5yZWFkRmlsZSk7XG5cbnR5cGUgQnVpbGRCdWlsZGVyT3V0cHV0ID0gQnVpbGRlck91dHB1dCAmIHtcbiAgYmFzZU91dHB1dFBhdGg6IHN0cmluZztcbiAgb3V0cHV0UGF0aHM6IHN0cmluZ1tdO1xuICBvdXRwdXRQYXRoOiBzdHJpbmc7XG59O1xuXG50eXBlIFNjaGVkdWxlQnVpbGRzT3V0cHV0ID0gQnVpbGRlck91dHB1dCAmIHtcbiAgc2VydmVyUmVzdWx0PzogQnVpbGRCdWlsZGVyT3V0cHV0O1xuICBicm93c2VyUmVzdWx0PzogQnVpbGRCdWlsZGVyT3V0cHV0O1xufTtcblxuLyoqXG4gKiBTY2hlZHVsZXMgdGhlIHNlcnZlciBhbmQgYnJvd3NlciBidWlsZHMgYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cyBpZiBib3RoIGJ1aWxkcyBhcmUgc3VjY2Vzc2Z1bC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3NjaGVkdWxlQnVpbGRzKFxuICBvcHRpb25zOiBQcmVyZW5kZXJCdWlsZGVyT3B0aW9ucyxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4pOiBQcm9taXNlPFNjaGVkdWxlQnVpbGRzT3V0cHV0PiB7XG4gIGNvbnN0IGJyb3dzZXJUYXJnZXQgPSB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nKG9wdGlvbnMuYnJvd3NlclRhcmdldCk7XG4gIGNvbnN0IHNlcnZlclRhcmdldCA9IHRhcmdldEZyb21UYXJnZXRTdHJpbmcob3B0aW9ucy5zZXJ2ZXJUYXJnZXQpO1xuXG4gIGNvbnN0IGJyb3dzZXJUYXJnZXRSdW4gPSBhd2FpdCBjb250ZXh0LnNjaGVkdWxlVGFyZ2V0KGJyb3dzZXJUYXJnZXQsIHtcbiAgICB3YXRjaDogZmFsc2UsXG4gICAgc2VydmljZVdvcmtlcjogZmFsc2UsXG4gICAgLy8gdG9kbzogaGFuZGxlIHNlcnZpY2Ugd29ya2VyIGF1Z21lbnRhdGlvblxuICB9KTtcbiAgY29uc3Qgc2VydmVyVGFyZ2V0UnVuID0gYXdhaXQgY29udGV4dC5zY2hlZHVsZVRhcmdldChzZXJ2ZXJUYXJnZXQsIHtcbiAgICB3YXRjaDogZmFsc2UsXG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgW2Jyb3dzZXJSZXN1bHQsIHNlcnZlclJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAoYnJvd3NlclRhcmdldFJ1bi5yZXN1bHQgYXMgdW5rbm93bikgYXMgQnVpbGRCdWlsZGVyT3V0cHV0LFxuICAgICAgKHNlcnZlclRhcmdldFJ1bi5yZXN1bHQgYXMgdW5rbm93bikgYXMgQnVpbGRCdWlsZGVyT3V0cHV0LFxuICAgIF0pO1xuXG4gICAgY29uc3Qgc3VjY2VzcyA9XG4gICAgICBicm93c2VyUmVzdWx0LnN1Y2Nlc3MgJiYgc2VydmVyUmVzdWx0LnN1Y2Nlc3MgJiYgYnJvd3NlclJlc3VsdC5iYXNlT3V0cHV0UGF0aCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGVycm9yID0gYnJvd3NlclJlc3VsdC5lcnJvciB8fCAoc2VydmVyUmVzdWx0LmVycm9yIGFzIHN0cmluZyk7XG5cbiAgICByZXR1cm4geyBzdWNjZXNzLCBlcnJvciwgYnJvd3NlclJlc3VsdCwgc2VydmVyUmVzdWx0IH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGUubWVzc2FnZSB9O1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFticm93c2VyVGFyZ2V0UnVuLnN0b3AoKSwgc2VydmVyVGFyZ2V0UnVuLnN0b3AoKV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBlYWNoIHJvdXRlIGFuZCB3cml0ZXMgdGhlbSB0b1xuICogPHJvdXRlPi9pbmRleC5odG1sIGZvciBlYWNoIG91dHB1dCBwYXRoIGluIHRoZSBicm93c2VyIHJlc3VsdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlbmRlclVuaXZlcnNhbChcbiAgcm91dGVzOiBzdHJpbmdbXSxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4gIGJyb3dzZXJSZXN1bHQ6IEJ1aWxkQnVpbGRlck91dHB1dCxcbiAgc2VydmVyUmVzdWx0OiBCdWlsZEJ1aWxkZXJPdXRwdXQsXG4gIGJyb3dzZXJPcHRpb25zOiBCcm93c2VyQnVpbGRlck9wdGlvbnMsXG4gIG51bVByb2Nlc3Nlcz86IG51bWJlcixcbik6IFByb21pc2U8UHJlcmVuZGVyQnVpbGRlck91dHB1dD4ge1xuICBjb25zdCBob3N0ID0gbmV3IE5vZGVKc1N5bmNIb3N0KCk7XG4gIGNvbnN0IHByb2plY3ROYW1lID0gY29udGV4dC50YXJnZXQgJiYgY29udGV4dC50YXJnZXQucHJvamVjdDtcbiAgaWYgKCFwcm9qZWN0TmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGJ1aWxkZXIgcmVxdWlyZXMgYSB0YXJnZXQuJyk7XG4gIH1cblxuICBjb25zdCByb290ID0gbm9ybWFsaXplKGNvbnRleHQud29ya3NwYWNlUm9vdCk7XG4gIGNvbnN0IHByb2plY3RNZXRhZGF0YSA9IGF3YWl0IGNvbnRleHQuZ2V0UHJvamVjdE1ldGFkYXRhKHByb2plY3ROYW1lKTtcbiAgY29uc3QgcHJvamVjdFJvb3QgPSByZXNvbHZlUGF0aChyb290LCBub3JtYWxpemUoKHByb2plY3RNZXRhZGF0YS5yb290IGFzIHN0cmluZykgfHwgJycpKTtcblxuICAvLyBVc2VycyBjYW4gc3BlY2lmeSBhIGRpZmZlcmVudCBiYXNlIGh0bWwgZmlsZSBlLmcuIFwic3JjL2hvbWUuaHRtbFwiXG4gIGNvbnN0IGluZGV4RmlsZSA9IGdldEluZGV4T3V0cHV0RmlsZShicm93c2VyT3B0aW9ucyk7XG4gIGNvbnN0IHsgc3R5bGVzOiBub3JtYWxpemVkU3R5bGVzT3B0aW1pemF0aW9uIH0gPSBub3JtYWxpemVPcHRpbWl6YXRpb24oXG4gICAgYnJvd3Nlck9wdGlvbnMub3B0aW1pemF0aW9uLFxuICApO1xuXG4gIC8vIFdlIG5lZWQgdG8gcmVuZGVyIHRoZSByb3V0ZXMgZm9yIGVhY2ggbG9jYWxlIGZyb20gdGhlIGJyb3dzZXIgb3V0cHV0LlxuICBmb3IgKGNvbnN0IG91dHB1dFBhdGggb2YgYnJvd3NlclJlc3VsdC5vdXRwdXRQYXRocykge1xuICAgIGNvbnN0IGJyb3dzZXJJbmRleElucHV0UGF0aCA9IHBhdGguam9pbihvdXRwdXRQYXRoLCBpbmRleEZpbGUpO1xuICAgIGxldCBpbmRleEh0bWwgPSBhd2FpdCByZWFkRmlsZShicm93c2VySW5kZXhJbnB1dFBhdGgsICd1dGY4Jyk7XG5cbiAgICBpZiAobm9ybWFsaXplZFN0eWxlc09wdGltaXphdGlvbi5pbmxpbmVDcml0aWNhbCkge1xuICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvY3JpdHRlcnMvaXNzdWVzLzY0XG4gICAgICBpbmRleEh0bWwgPSBpbmRleEh0bWwucmVwbGFjZShcbiAgICAgICAgLyBtZWRpYT1cXFwicHJpbnRcXFwiIG9ubG9hZD1cXFwidGhpc1xcLm1lZGlhPSdhbGwnXCI+PG5vc2NyaXB0PjxsaW5rIC4rPz48XFwvbm9zY3JpcHQ+L2csXG4gICAgICAgICc+JyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBiYXNlT3V0cHV0UGF0aCA9ICcnIH0gPSBzZXJ2ZXJSZXN1bHQ7XG4gICAgY29uc3QgbG9jYWxlRGlyZWN0b3J5ID0gcGF0aC5yZWxhdGl2ZShicm93c2VyUmVzdWx0LmJhc2VPdXRwdXRQYXRoLCBvdXRwdXRQYXRoKTtcbiAgICBjb25zdCBzZXJ2ZXJCdW5kbGVQYXRoID0gcGF0aC5qb2luKGJhc2VPdXRwdXRQYXRoLCBsb2NhbGVEaXJlY3RvcnksICdtYWluLmpzJyk7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHNlcnZlckJ1bmRsZVBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHRoZSBtYWluIGJ1bmRsZTogJHtzZXJ2ZXJCdW5kbGVQYXRofWApO1xuICAgIH1cblxuICAgIGNvbnN0IHNwaW5uZXIgPSBvcmEoYFByZXJlbmRlcmluZyAke3JvdXRlcy5sZW5ndGh9IHJvdXRlKHMpIHRvICR7b3V0cHV0UGF0aH0uLi5gKS5zdGFydCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdvcmtlckZpbGUgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAncmVuZGVyLmpzJyk7XG4gICAgICBjb25zdCBjaGlsZFByb2Nlc3NlcyA9IHNoYXJkQXJyYXkocm91dGVzLCBudW1Qcm9jZXNzZXMpLm1hcChcbiAgICAgICAgKHJvdXRlc1NoYXJkKSA9PlxuICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZvcmsod29ya2VyRmlsZSwgW1xuICAgICAgICAgICAgICBpbmRleEh0bWwucmVwbGFjZShcbiAgICAgICAgICAgICAgICAnPC9odG1sPicsXG4gICAgICAgICAgICAgICAgJzwhLS0gVGhpcyBwYWdlIHdhcyBwcmVyZW5kZXJlZCB3aXRoIEFuZ3VsYXIgVW5pdmVyc2FsIC0tPlxcbjwvaHRtbD4nLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBpbmRleEZpbGUsXG4gICAgICAgICAgICAgIHNlcnZlckJ1bmRsZVBhdGgsXG4gICAgICAgICAgICAgIG91dHB1dFBhdGgsXG4gICAgICAgICAgICAgIGJyb3dzZXJPcHRpb25zLmRlcGxveVVybCB8fCAnJyxcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFN0eWxlc09wdGltaXphdGlvbi5pbmxpbmVDcml0aWNhbCA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRTdHlsZXNPcHRpbWl6YXRpb24ubWluaWZ5ID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgICAgICAgLi4ucm91dGVzU2hhcmQsXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAub24oJ21lc3NhZ2UnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlbmRlciAke2RhdGEub3V0cHV0SW5kZXhQYXRofS5cXG5FcnJvcjogJHtkYXRhLmVycm9yfWApLFxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxvZ0xldmVsKSB7XG4gICAgICAgICAgICAgICAgICBzcGlubmVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmxvZyhkYXRhLmxvZ0xldmVsLCBkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgc3Bpbm5lci5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLm9uKCdleGl0JywgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChjaGlsZFByb2Nlc3Nlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHNwaW5uZXIuZmFpbChgUHJlcmVuZGVyaW5nIHJvdXRlcyB0byAke291dHB1dFBhdGh9IGZhaWxlZC5gKTtcblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgfVxuXG4gICAgc3Bpbm5lci5zdWNjZWVkKGBQcmVyZW5kZXJpbmcgcm91dGVzIHRvICR7b3V0cHV0UGF0aH0gY29tcGxldGUuYCk7XG5cbiAgICBpZiAoYnJvd3Nlck9wdGlvbnMuc2VydmljZVdvcmtlcikge1xuICAgICAgc3Bpbm5lci5zdGFydCgnR2VuZXJhdGluZyBzZXJ2aWNlIHdvcmtlci4uLicpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYXVnbWVudEFwcFdpdGhTZXJ2aWNlV29ya2VyKFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgcHJvamVjdFJvb3QsXG4gICAgICAgICAgbm9ybWFsaXplKG91dHB1dFBhdGgpLFxuICAgICAgICAgIGJyb3dzZXJPcHRpb25zLmJhc2VIcmVmIHx8ICcvJyxcbiAgICAgICAgICBicm93c2VyT3B0aW9ucy5uZ3N3Q29uZmlnUGF0aCxcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNwaW5uZXIuZmFpbCgnU2VydmljZSB3b3JrZXIgZ2VuZXJhdGlvbiBmYWlsZWQuJyk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgICB9XG5cbiAgICAgIHNwaW5uZXIuc3VjY2VlZCgnU2VydmljZSB3b3JrZXIgZ2VuZXJhdGlvbiBjb21wbGV0ZS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnJvd3NlclJlc3VsdDtcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGJyb3dzZXIgYW5kIHNlcnZlciwgdGhlbiByZW5kZXJzIGVhY2ggcm91dGUgaW4gb3B0aW9ucy5yb3V0ZXNcbiAqIGFuZCB3cml0ZXMgdGhlbSB0byBwcmVyZW5kZXIvPHJvdXRlPi9pbmRleC5odG1sIGZvciBlYWNoIG91dHB1dCBwYXRoIGluXG4gKiB0aGUgYnJvd3NlciByZXN1bHQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlKFxuICBvcHRpb25zOiBQcmVyZW5kZXJCdWlsZGVyT3B0aW9ucyxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4pOiBQcm9taXNlPFByZXJlbmRlckJ1aWxkZXJPdXRwdXQ+IHtcbiAgY29uc3QgYnJvd3NlclRhcmdldCA9IHRhcmdldEZyb21UYXJnZXRTdHJpbmcob3B0aW9ucy5icm93c2VyVGFyZ2V0KTtcbiAgY29uc3QgYnJvd3Nlck9wdGlvbnMgPSAoKGF3YWl0IGNvbnRleHQuZ2V0VGFyZ2V0T3B0aW9ucyhcbiAgICBicm93c2VyVGFyZ2V0LFxuICApKSBhcyB1bmtub3duKSBhcyBCcm93c2VyQnVpbGRlck9wdGlvbnM7XG4gIGNvbnN0IHRzQ29uZmlnUGF0aCA9XG4gICAgdHlwZW9mIGJyb3dzZXJPcHRpb25zLnRzQ29uZmlnID09PSAnc3RyaW5nJyA/IGJyb3dzZXJPcHRpb25zLnRzQ29uZmlnIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHJvdXRlcyA9IGF3YWl0IGdldFJvdXRlcyhvcHRpb25zLCB0c0NvbmZpZ1BhdGgsIGNvbnRleHQpO1xuICBpZiAoIXJvdXRlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGFueSByb3V0ZXMgdG8gcHJlcmVuZGVyLmApO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3NjaGVkdWxlQnVpbGRzKG9wdGlvbnMsIGNvbnRleHQpO1xuICBjb25zdCB7IHN1Y2Nlc3MsIGVycm9yLCBicm93c2VyUmVzdWx0LCBzZXJ2ZXJSZXN1bHQgfSA9IHJlc3VsdDtcbiAgaWYgKCFzdWNjZXNzIHx8ICFicm93c2VyUmVzdWx0IHx8ICFzZXJ2ZXJSZXN1bHQpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzLCBlcnJvciB9IGFzIEJ1aWxkZXJPdXRwdXQ7XG4gIH1cblxuICByZXR1cm4gX3JlbmRlclVuaXZlcnNhbChcbiAgICByb3V0ZXMsXG4gICAgY29udGV4dCxcbiAgICBicm93c2VyUmVzdWx0LFxuICAgIHNlcnZlclJlc3VsdCxcbiAgICBicm93c2VyT3B0aW9ucyxcbiAgICBvcHRpb25zLm51bVByb2Nlc3NlcyxcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQnVpbGRlcihleGVjdXRlKTtcbiJdfQ==